<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Animate Flat Lines with Separate Arc Width and Circle Radius</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<script src="https://cdn.jsdelivr.net/npm/@deck.gl/core@latest/dist.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@deck.gl/layers@latest/dist.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@deck.gl/mapbox@latest/dist.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.css" rel="stylesheet" />
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>

<div id="map"></div>

<script>
// Initialize the Mapbox map
mapboxgl.accessToken = 'pk.eyJ1IjoiaW1yYW5kYXRhIiwiYSI6ImNtMDRlaHh1YTA1aDEybHI1ZW12OGh4cDcifQ.fHLLFYQx7JKPUp2Sl1jtYg';
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/dark-v11',
    center: [-30, 20], // Centered to show both UK and USA
    zoom: 2
});

// Origins
const origins = {
    'UK': [-0.1276, 51.5074], // London, UK
    'USA': [-77.0369, 38.9072] // Washington DC, USA
};

// Data containers
let countryCoordinates = {};
let countryConnections = {
    'UK': new Set(),  // Use Set to ensure unique destinations
    'USA': new Set()
};

// Load the location data
async function loadLocationData() {
    try {
        const response = await fetch('location.csv');
        const data = await response.text();
        const rows = data.split('\n').slice(1); // Skip header row
        rows.forEach(row => {
            const [location, lat, long] = row.split(',');
            if (location && lat && long) {
                countryCoordinates[location.trim()] = [parseFloat(long), parseFloat(lat)];
            }
        });
        console.log('Location data loaded:', countryCoordinates);
    } catch (error) {
        console.error('Error loading location data:', error);
    }
}

// Load the article data
async function loadArticleData() {
    try {
        const response = await fetch('article_details.json');
        const articles = await response.json();

        articles.forEach(article => {
            const country = article.country;
            if (country === 'UK' || country === 'USA') {
                const mentionedCountries = Object.keys(article.country_frequencies);
                mentionedCountries.forEach(mentionedCountry => {
                    if (countryCoordinates[mentionedCountry] && mentionedCountry !== country) {
                        countryConnections[country].add(mentionedCountry); // Use Set to ensure uniqueness
                    }
                });
            }
        });
        console.log('Article data loaded:', countryConnections);
    } catch (error) {
        console.error('Error loading article data:', error);
    }
}

// Function to normalize longitude to the range [-180, 180]
function normalizeLongitude(lon) {
    while (lon > 180) lon -= 360;
    while (lon < -180) lon += 360;
    return lon;
}

// Function to compute offset destination for visual separation
function computeOffsetDestination(destination, index, total) {
    const offset = 0.6; // Adjust this value to control the distance between lines
    const angleStep = (2 * Math.PI) / total; // Equal spacing around the circle
    const angle = index * angleStep;

    const offsetX = Math.cos(angle) * offset;
    const offsetY = Math.sin(angle) * offset;
    
    return [destination[0] + offsetX, destination[1] + offsetY];
}

// Deck.gl layer setup
async function setupDeckLayer() {
    await loadLocationData();
    await loadArticleData();

    const arcs = [];
    const destinations = []; // For storing destination points for circles

    Object.keys(countryConnections).forEach((origin, originIndex) => {
        const originCoords = origins[origin];

        // Create an array from the Set to determine total number of connections to each destination
        const destinationsArray = Array.from(countryConnections[origin]);

        destinationsArray.forEach((destination, destinationIndex) => {
            const destinationCoords = countryCoordinates[destination];
            if (originCoords && destinationCoords) {
                // Normalize longitudes only to keep in visible bounds
                const adjustedOriginCoords = [normalizeLongitude(originCoords[0]), originCoords[1]];
                // Compute a slight offset for overlapping lines
                const adjustedDestinationCoords = computeOffsetDestination(
                    [normalizeLongitude(destinationCoords[0]), destinationCoords[1]], 
                    destinationIndex, 
                    destinationsArray.length
                );

                // Set line color with adjustable opacity
                const baseColor = origin === 'UK' ? [0, 123, 191] : [255, 0, 0]; // RGB colors
                const arcOpacity = 100; // Adjust this for desired arc opacity (0-255)
                const dotOpacity = 200; // Adjust this for desired dot opacity (0-255)
                const arcColor = [...baseColor, arcOpacity]; // Arc color with transparency
                const dotColor = [...baseColor, dotOpacity]; // Dot color with transparency

                arcs.push({
                    sourcePosition: adjustedOriginCoords,
                    targetPosition: adjustedDestinationCoords,
                    color: arcColor,
                    width: 0.5 // Adjust width here for arcs
                });

                // Add destination point to destinations array for circle rendering
                destinations.push({
                    position: adjustedDestinationCoords,
                    color: dotColor, // Different opacity for dots
                    radius: 3 // Adjust radius here as needed for circles
                });
            } else {
                console.warn('Missing coordinates for:', origin, destination);
            }
        });
    });

    if (arcs.length === 0) {
        console.warn('No arcs to display.');
    } else {
        console.log('Arcs to display:', arcs);
    }

    // Create Deck.gl ArcLayer with modified settings
    const arcLayer = new deck.ArcLayer({
        id: 'arc-layer',
        data: arcs,
        getSourcePosition: d => d.sourcePosition,
        getTargetPosition: d => d.targetPosition,
        getSourceColor: d => d.color,
        getTargetColor: d => d.color,
        getWidth: d => d.width, // Dynamic width for arcs
        getHeight: 0.5, // Set height to 0 to flatten the arcs
        greatCircle: false, // Disable great circle to treat map as flat
        autoHighlight: true,
        pickable: true,
        getTooltip: ({object}) => object && `From: ${object.sourcePosition}, To: ${object.targetPosition}`
    });

    // Create Deck.gl ScatterplotLayer for destination circles with adjustable radius
    const scatterplotLayer = new deck.ScatterplotLayer({
        id: 'scatterplot-layer',
        data: destinations,
        getPosition: d => d.position,
        getFillColor: d => d.color,
        getRadius: d => d.radius, // Dynamic radius for dots
        radiusMinPixels: 3, // Adjust minimum pixel size of the circle
        radiusMaxPixels: 5 // Adjust maximum pixel size of the circle to allow larger radius
    });

    // Initialize Deck.gl overlay and add both layers to Mapbox
    const deckOverlay = new deck.MapboxOverlay({
        layers: [arcLayer, scatterplotLayer]
    });

    map.addControl(deckOverlay); // Add Deck.gl overlay directly as a control to Mapbox map
}

// Initialize the map with Deck.gl overlay
map.on('load', setupDeckLayer);

</script>

</body>
</html>
